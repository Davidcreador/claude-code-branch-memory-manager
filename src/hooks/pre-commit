#!/bin/bash
# Claude Code Branch Memory Manager - Pre Commit Hook
# Professional git hook that saves work context before commits

# Hook metadata
HOOK_NAME="pre-commit"
HOOK_VERSION="2.0.0"
HOOK_DESCRIPTION="Saves current work context to branch memory before commits"

# Exit early if hooks are disabled
if [[ "${CLAUDE_MEMORY_DISABLE_HOOKS:-}" == "1" ]]; then
    exit 0
fi

# Source the Claude Memory Manager libraries
CLAUDE_MEMORY_HOME="${HOME}/.claude-memory"
if [[ ! -d "$CLAUDE_MEMORY_HOME" ]]; then
    echo "Warning: Claude Memory Manager not found at $CLAUDE_MEMORY_HOME" >&2
    exit 0
fi

# Source libraries with error handling
for lib in logger config git-utils core errors; do
    lib_file="$CLAUDE_MEMORY_HOME/lib/${lib}.sh"
    if [[ -f "$lib_file" ]]; then
        # shellcheck source=/dev/null
        source "$lib_file"
    else
        echo "Warning: Library not found: $lib_file" >&2
        exit 0
    fi
done

# Initialize error context
set_error_context "hook" "$HOOK_NAME"
set_error_context "hook_version" "$HOOK_VERSION"

# Main hook execution
main() {
    local component="pre-commit"
    
    # Performance timing
    local start_time
    start_time=$(date +%s%3N)
    
    log_info "Pre-commit hook triggered" "$component"
    
    # Validate environment
    if ! validate_git_repo "$component"; then
        log_error "Hook running outside git repository" "$component"
        exit 0
    fi
    
    # Check if hooks are enabled in configuration
    if [[ "$(get_config_bool "enable_hooks")" != "true" ]]; then
        log_debug "Hooks are disabled in configuration" "$component"
        exit 0
    fi
    
    # Check if auto-save on commit is enabled
    if [[ "$(get_config_bool "auto_save_on_commit")" != "true" ]]; then
        log_debug "Auto-save on commit is disabled" "$component"
        exit 0
    fi
    
    # Get current branch
    local current_branch
    current_branch=$(get_current_branch "$component")
    
    if [[ "$current_branch" == "detached-head" || "$current_branch" == "unknown" ]]; then
        log_info "Not on a named branch, skipping memory update" "$component"
        exit 0
    fi
    
    set_error_context "current_branch" "$current_branch"
    
    # Check if we have a memory file to update
    local current_memory
    current_memory=$(get_current_memory_file)
    
    if [[ ! -f "$current_memory" ]]; then
        log_debug "No current memory file found, skipping commit context" "$component"
        exit 0
    fi
    
    # Get commit message from git (if available)
    local commit_message=""
    if [[ -f ".git/COMMIT_EDITMSG" ]]; then
        commit_message=$(head -1 ".git/COMMIT_EDITMSG" 2>/dev/null | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
    fi
    
    set_error_context "commit_message" "$commit_message"
    
    # Get staged files for context
    local staged_files
    staged_files=$(get_staged_files "$component")
    set_error_context "staged_files_count" "$(echo "$staged_files" | wc -l)"
    
    log_info "Adding commit context to memory for branch: $current_branch" "$component"
    log_debug "Staged files: $(echo "$staged_files" | wc -l) files" "$component"
    
    # Add commit context with safe operation
    safe_operation "add_commit_context" \
        "log_warn 'Failed to add commit context, commit will proceed' '$component'" \
        add_commit_context "$commit_message"
    
    # Save updated memory to branch-specific file
    local save_description="Pre-commit auto-save"
    if [[ -n "$commit_message" ]]; then
        save_description="Pre-commit: $commit_message"
    fi
    
    safe_operation "save_branch_memory" \
        "log_warn 'Failed to save branch memory, commit will proceed' '$component'" \
        save_branch_memory "$current_branch" "$save_description"
    
    # Log performance metrics
    local end_time
    end_time=$(date +%s%3N)
    local duration=$((end_time - start_time))
    
    if [[ "$(get_config_bool "enable_performance_logging")" == "true" ]]; then
        log_perf "pre-commit" "$duration" "$component"
    fi
    
    log_info "Pre-commit hook completed successfully" "$component"
    
    # Log event for monitoring
    local event_data
    event_data=$(printf '{"branch":"%s","staged_files":%d,"duration_ms":%d}' \
        "$current_branch" "$(echo "$staged_files" | wc -l)" "$duration")
    log_event "pre_commit" "$event_data" "$component"
    
    # Continue with commit (return 0)
    exit 0
}

# Error handling wrapper
execute_with_error_handling() {
    # Set up error context
    set_error_context "pwd" "$(pwd)"
    set_error_context "user" "${USER:-unknown}"
    set_error_context "timestamp" "$(date '+%Y-%m-%d %H:%M:%S')"
    
    # Execute main function with error handling
    if ! main; then
        log_error "Pre-commit hook failed" "pre-commit"
        
        # Create error report in debug mode
        if [[ "$(get_config_bool "debug_enabled")" == "true" ]]; then
            local error_report
            error_report=$(create_error_report)
            log_error "Error report created: $error_report" "pre-commit"
        fi
        
        # Don't fail the commit, just log the error
        exit 0
    fi
}

# Hook timeout handling
timeout_handler() {
    log_error "Pre-commit hook timed out" "pre-commit"
    exit 0
}

# Set up timeout
HOOK_TIMEOUT=$(get_config_int "hook_timeout" 30)
trap timeout_handler ALRM
if command -v timeout &>/dev/null; then
    # Use timeout command if available
    timeout "$HOOK_TIMEOUT" bash -c "execute_with_error_handling"
else
    # Fallback without timeout
    execute_with_error_handling
fi